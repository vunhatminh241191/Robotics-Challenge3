#pragma config(Sensor, S1,     ultraSonic,     sensorSONAR)
#pragma config(Sensor, S2,     leftLight,      sensorLightActive)
#pragma config(Sensor, S3,     rightLight,     sensorLightActive)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
* THIS ROBOT CONTROLS: MOTORS, ULTRASONIC SENSOR, AND BOTH LIGHT SENSORS ON GROUND
*/
#define SAMPLES 50
#define BASESPEED 20
#define WHITE 20 //light sensor white reading value
#define BLACK 7 //light sensor black reading value
#define MAX_DIST 90 //maximum distance for the robot to read
#define MIN_DIST 3 //minimum distance for the robot to read
#define DEATH 0
#define AVOID 1
#define ESCAPE 2
#define INVESTIGATE 3
#define FEEDING 4
#define WANDER 5
#define FULL 120
#define HUNGRY 60
#define DANGER 30
#define DEAD 0
#define STOP 0

//flags
bool content;
bool hungry;
bool starving;
bool dead;
bool scared;
bool bump;
bool feeding;
bool gradient;
bool escape;
int energyLevel;
int fearLevel;
bool objectFound = false; //flag for priority if object is found
bool lightFlash = false; //flag for when light flashes top sensor
int counter;

int State;

//speeds
int lSpeed, rSpeed = 0;

int distance;
ubyte data[3];

/**
*This function finds the speed proportional to the distance
*Parameters: dist is the distance of the object.
*Returns: speed to distance ratio.
**/
int sonicSpeed(int dist)
{
	if(dist>=MAX_DIST)
		dist = 100;
	if(dist<MIN_DIST)
		dist = 0;
	return dist;
}

/**
*This function is called when object is no longer within range
*Parameters: None
*Returns: boolean based on object's detection
**/
bool lostTarget() //this function will
{
	rSpeed = 0; //stop both motors
	lSpeed = 0;
	wait1Msec(100);
	for(int i = 0;i<100;i++)
	{
		wait1Msec(1); //essentially wait 100ms
		rSpeed = 25; //turn left for 100ms
		lSpeed = -25;
		if(distance <= MAX_DIST) //if object within range set flag to true
			return true;
	}
	rSpeed = 0; //stop motors
	lSpeed = 0;
	wait1Msec(100);
	for(int i = 0;i<200;i++)
	{
		wait1Msec(1); //essentially wait 100ms
		rSpeed = -25; //turn right for 100ms
		lSpeed = 25;
		if(distance <= MAX_DIST) //if object within range set flag to true
			return true;
	}
	//playTone(10000, 10);
	return false; //we lost the target
}

/**
*Function is called when an object is within range
*Parameters: none
*returns: void
**/
void targetAquired()
{
	int speed = 0;
	while(true)
	{
		if(distance>MAX_DIST)
		{
			if(!lostTarget()) //if we lose the target, check for it
			{
				break; //we lost the target, break out
			}
		}
		else if(distance<=MIN_DIST)
		{
			rSpeed = 0; //stop motors
			lSpeed = 0;
			wait1Msec(5000); //wait 5 seconds
			rSpeed=-50; //reverse motors
			lSpeed=-50;
			wait1Msec(1000); //reverse motors for 1 second
			rSpeed=50; //turn left
			lSpeed=0;
			wait1Msec(1000); //turn left for 1 second
			lSpeed=50;//drive forward
			break;
		} else
		{
			speed = sonicSpeed(distance); //if object is found, find its proportional speed
			rSpeed = speed; //set that speed to motors
			lSpeed = speed;
			//playTone(speed*50, 5); //debugging
		}
	}
}

void backUp()
{
	rSpeed = -1*BASESPEED;
	lSpeed = -1*BASESPEED;
	wait1Msec(500);
	lSpeed = 0;
	rSpeed = 0;
}

void randomTurning()
{
	int randTemp = (random[6]+2)*250;
	if(random[2])
	{
		rSpeed = BASESPEED;
		lSpeed = -1*(BASESPEED-10);
		wait1Msec(randTemp);
	}
	else
	{
		rSpeed = -1*(BASESPEED-10);
		lSpeed = BASESPEED;
		wait1Msec(randTemp);
	}
	lSpeed = 0;
	rSpeed = 0;
}
/*
*Function to make the robot do a drunk-sailor walk
*Parameters: none
*returns: none
*/
void drunkTurn()
{
	if(objectFound)
	{
		return; //we want to break out if an object is found
	}
	//get direction and duration
	int Dir = random[2];
	//time is for turning duration, time2 is for the forward duration.
	int turnDuration = (random[5]+1) * 350;
	int forwardDuration = (random[3]+1) * 100;

	//initial turn off-course
	if(Dir==1) {
		rSpeed = BASESPEED+15;
		lSpeed = BASESPEED;
	} else
	{
		lSpeed = BASESPEED;
		rSpeed = BASESPEED+15;
	}

	//move straight
	wait1Msec(turnDuration);
	lSpeed = BASESPEED;
	rSpeed = BASESPEED;
	wait1Msec(forwardDuration);

	//Turn back to the forward position
	if(Dir==1) {
		lSpeed = BASESPEED;
		rSpeed = BASESPEED+15;
	} else
	{
		lSpeed = BASESPEED+15;
		rSpeed = BASESPEED;
	}
	wait1Msec(turnDuration);
	//set mototrs back to normal speed, straight ahead.
	lSpeed = BASESPEED;
	rSpeed = BASESPEED;
}

//This function is called when both bumpers have read a value. the robot
//beeps, backs up, then waits for 2 seconds. Then it chooses a random direction
//and turns in that direction for a random amount of time.
void bothD()
{
	playTone(2400, 100);
	backUp();
	wait1Msec(2000);
	randomTurning();
}

//When a left bumb is detected wait 100ms.
//If in this 100ms we detect the right bumper as well, then we stop both motors
//and proceed with the bothD() function. Otherwise, we stop both motors, reverse
//for a little, and then turn a random amount to the right.
void leftD()
{
	wait1Msec(100); //wait .1 sec
	if(data[1] == 'y') //check to see if perpendicular
	{
		lSpeed = 0;
		rSpeed = 0;
		bothD(); //if perpendicular
	}
	else //if not perpendicular, follow normal procedure
	{
		lSpeed = 0;
		rSpeed = 0;
		wait1Msec(50);
		backUp();
		rSpeed = BASESPEED; //turn left
		lSpeed = -1*BASESPEED;
		wait1Msec((random[4]+3)*100); //500
	}
}

//When a right bumb is detected wait 100ms.
//If in this 100ms we detect the left bumper as well, then we stop both motors
//and proceed with the bothD() function. Otherwise, we stop both motors, reverse
//for a little, and then turn a random amount to the left.
void rightD()
{
	wait1Msec(100); //wait .1 sec
	if(data[0]=='y') //check to see if perpendicular
	{
		lSpeed = 0;
		rSpeed = 0;
		bothD(); //if perpendicular
	}
	else //if not perpendicular, follow normal procedure
	{
		lSpeed = 0;
		rSpeed = 0;
		wait1Msec(50);
		backUp();
		rSpeed = -1*BASESPEED;
		lSpeed = BASESPEED;
		wait1Msec((random[4]+3)*100); //500
	}
}

void obstacle()
{
	if(data[0]=='y')
		leftD();
	else
		rightD();
}

void runAway()
{
	backUp();
	randomTurning();
	while(bump){}
	for(int i = 0; i<fearLevel; i++)
	{
		while(bump){}
		rSpeed = BASESPEED+(fearLevel/4);
		lSpeed = BASESPEED+(fearLevel/4);
		wait1Msec(40);
	}
	rSpeed = 0;
	lSpeed = 0;
	escape = false;
}

task commTask()
{
	nxtEnableHSPort();
	nxtSetHSBaudRate(9600);  // can go as high as 921600 BAUD
	nxtHS_Mode = hsRawMode;
	while(true)
	{
		while (nxtGetAvailHSBytes() < 4) EndTimeSlice(); // wait for the two bytes to come in.
		{
			nxtReadRawHS(&data[0], 3*sizeof(ubyte));
		}
		if(data[2]=='y') {
			lightFlash = true;
			escape = true;
		}
		if(data[0]=='y' || data[1]=='y')
			bump = true;
	}
}
/**
*Task that runs continuously and calls drunkTurn function every few seconds.
**/
task invertMotorsTask()
{
	while(true)
	{
		while(State==WANDER)
		{
			wait1Msec((random[6]+3)*250); //wait 1 to 3 seconds (250mS resolution)
			drunkTurn();
		}
	}
}

task runMotors()
{
	while(true){
		motor[leftMotor] = lSpeed;
		motor[rightMotor] = rSpeed;
	}
}

task getReadingTask()
{
	int total_dist = 0;
	int cSuccess = 0;
	int i,j;
	while(true)
	{
		cSuccess = 0;
		for(j = 0; j < 10; j++) //we need to ignore false positives
		{
			wait1Msec(10);
			total_dist = 0;
			for(i = 0;i<SAMPLES;i++) //we need to make sure the reading is good
			{
				total_dist += SensorValue[ultraSonic];
			}
			distance = total_dist/SAMPLES;
			if(distance<=MAX_DIST)
			{
				cSuccess++;
			}
		}
		if(cSuccess>=9) //indicates if we have a 90% success rate with distance
			objectFound = true;
	}
}

task energyRate()
{
	while(true)
	{
		if(dead)
			break;
		else
		{
			while(FEEDING && energyLevel<=FULL)
			{
				energyLevel++;
				wait1Msec(1000);
			}
			while(!FEEDING && !dead)
			{
				energyLevel--;
				wait1Msec(2000);
			}
		}
	}
}

void fearCounter()
{
	lightFlash = false;
	counter = 0;
	while(counter<60 && !lightFlash)
	{
		counter++;
		wait1Msec(1000);
	}
}

task fearState()
{
	fearLevel = 100;
	scared = false;
	while(true)
	{
		if(counter>=60)
		{
			scared = false;
		}
		while(fearLevel < 100 && !scared && !lightFlash)
		{
			fearLevel++;
			wait1Msec(2400);
		}
		if(lightFlash)
		{
			fearCounter();
			if(scared)
			{
				if(fearLevel<=25)
					fearLevel = 0;
				else
					fearLevel -= 25;
			}
			if(!scared)
				scared = true;
			runAway();
		}
	}
}

task energyState()
{
	while(1)
	{
		if(energyLevel>HUNGRY)
		{
			content = true;
			hungry = false;
			starving = false;
			dead = false;
		}
		else if(energyLevel>DANGER && energyLevel<=HUNGRY)
		{
			content = false;
			hungry = true;
			starving = false;
			dead = false;
		}
		else if(energyLevel<=DANGER && energyLevel>DEATH)
		{
			content = false;
			hungry = false;
			starving = true;
			dead = false;
		}
		else
		{
			content = false;
			hungry = false;
			starving = false;
			dead = true;
		}
	}
}
task displayValues()
{
	while(1)
	{
		eraseDisplay();
		displayCenteredBigTextLine(1, "F=%d", fearLevel);
		if(scared)
			displayCenteredBigTextLine(3, "Scared");
		else
			displayCenteredBigTextLine(3, "!Scared");
		displayCenteredBigTextLine(5, "%d", counter);
		wait1Msec(100);
	}
}
task main()
{
	startTask(runMotors);
	startTask(fearState);
	startTask(energyState);
	//startTask(getReadingTask);
	startTask(invertMotorsTask);
	startTask(energyRate);
	startTask(commTask);
	startTask(displayValues);

	/*
	bool scared;
	bool bump;
	bool feeding;
	bool escape;
	bool objectFound;
	bool gradient;
	*/

	energyLevel = FULL;
	distance = SensorValue[ultraSonic];
	while(true)
	{
		if(dead) {
			State = DEATH;
			}	else if (bump) { //bumper
			State = AVOID;
			} else if (escape && fearLevel > 0 && !starving) {
			State = ESCAPE;
			} else {
			State = WANDER;
		}
		switch(State) {
		case DEATH:
			scared = false;
			bump = false;
			feeding = false;
			escape = false;
			objectFound = false;
			gradient = false;
			break;
		case AVOID: //did we hit a bumper?
			feeding = false;
			objectFound = false;
			gradient = false;
			break;
		case ESCAPE:
			feeding = false;
			objectFound = false;
			gradient = false;
			break;
		case WANDER:
			break;
		}
	}
}
