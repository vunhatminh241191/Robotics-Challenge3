#pragma config(Sensor, S1,     ultraSonic,     sensorSONAR)
#pragma config(Sensor, S2,     leftLight,      sensorLightActive)
#pragma config(Sensor, S3,     rightLight,     sensorLightActive)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
* THIS ROBOT CONTROLS: MOTORS, ULTRASONIC SENSOR, AND BOTH LIGHT SENSORS ON GROUND
*/
#define SAMPLES 50
#define BASESPEED 40
#define WHITE 20 //light sensor white reading value
#define BLACK 7 //light sensor black reading value
#define MAX_DIST 90 //maximum distance for the robot to read
#define MIN_DIST 3 //minimum distance for the robot to read
#define DEATH 0
#define AVOID 1
#define ESCAPE 2
#define INVESTIGATE 3
#define FEEDING 4
#define WANDER 5
#define FULL 120
#define HUNGRY 60
#define DANGER 30
#define DEAD 0
#define STOP 0

//flags
bool content;
bool hungry;
bool starving;
bool dead;
bool escape;
bool scared;
bool feeding;
int energyLevel;
int fearLevel;
bool objectFound = false; //flag for priority if object is found

int State;

//speeds
int avoidLSpeed;
int avoidRSpeed;
int escapeLSpeed;
int escapeRSpeed;
int investLSpeed;
int investRSpeed;
int feedLSpeed;
int feedRSpeed;
int wanderLSpeed;
int wanderRSpeed;
int lSpeed, rSpeed = 0;

int distance;
ubyte data[3];

/**
*This function finds the speed proportional to the distance
*Parameters: dist is the distance of the object.
*Returns: speed to distance ratio.
**/
int sonicSpeed(int dist)
{
	if(dist>=MAX_DIST)
		dist = 100;
	if(dist<MIN_DIST)
		dist = 0;
	return dist;
}

/**
*This function is called when object is no longer within range
*Parameters: None
*Returns: boolean based on object's detection
**/
bool lostTarget() //this function will
{
	rSpeed = 0; //stop both motors
	lSpeed = 0;
	wait1Msec(100);
	for(int i = 0;i<100;i++)
	{
		wait1Msec(1); //essentially wait 100ms
		rSpeed = 25; //turn left for 100ms
		lSpeed = -25;
		if(distance <= MAX_DIST) //if object within range set flag to true
			return true;
	}
	rSpeed = 0; //stop motors
	lSpeed = 0;
	wait1Msec(100);
	for(int i = 0;i<200;i++)
	{
		wait1Msec(1); //essentially wait 100ms
		rSpeed = -25; //turn right for 100ms
		lSpeed = 25;
		if(distance <= MAX_DIST) //if object within range set flag to true
			return true;
	}
	playTone(10000, 10);
	return false; //we lost the target
}

/**
*Function is called when an object is within range
*Parameters: none
*returns: void
**/
void targetAquired()
{
	int speed = 0;
	while(true)
	{
		if(distance>MAX_DIST)
		{
			if(!lostTarget()) //if we lose the target, check for it
			{
				break; //we lost the target, break out
			}
		}
		else if(distance<=MIN_DIST)
		{
			rSpeed = 0; //stop motors
			lSpeed = 0;
			wait1Msec(5000); //wait 5 seconds
			rSpeed=-50; //reverse motors
			lSpeed=-50;
			wait1Msec(1000); //reverse motors for 1 second
			rSpeed=50; //turn left
			lSpeed=0;
			wait1Msec(1000); //turn left for 1 second
			lSpeed=50;//drive forward
			break;
		} else
		{
			speed = sonicSpeed(distance); //if object is found, find its proportional speed
			rSpeed = speed; //set that speed to motors
			lSpeed = speed;
			playTone(speed*50, 5); //debugging
		}
	}
}

/*
*Function to make the robot do a drunk-sailor walk
*Parameters: none
*returns: none
*/
void drunkTurn()
{
	if(objectFound)
	{
		return; //we want to break out if an object is found
	}
	//get direction and duration
	int Dir = random[2];
	//time is for turning duration, time2 is for the forward duration.
	int turnDuration = (random[5]+1) * 350;
	int forwardDuration = (random[3]+1) * 100;

	//initial turn off-course
	if(Dir==1) {
		rSpeed = BASESPEED+15;
		lSpeed = BASESPEED;
	} else
	{
		lSpeed = BASESPEED;
		rSpeed = BASESPEED+15;
	}

	//move straight
	wait1Msec(turnDuration);
	lSpeed = BASESPEED;
	rSpeed = BASESPEED;
	wait1Msec(forwardDuration);

	//Turn back to the forward position
	if(Dir==1) {
		lSpeed = BASESPEED;
		rSpeed = BASESPEED+15;
	} else
	{
		lSpeed = BASESPEED+15;
		rSpeed = BASESPEED;
	}
	wait1Msec(turnDuration);
	//set mototrs back to normal speed, straight ahead.
	lSpeed = BASESPEED;
	rSpeed = BASESPEED;
}

//This function is called when both bumpers have read a value. the robot
//beeps, backs up, then waits for 2 seconds. Then it chooses a random direction
//and turns in that direction for a random amount of time.
void bothD()
{
	playTone(2400, 100);
	rSpeed = -1*BASESPEED;
	lSpeed = -1*BASESPEED;
	wait1Msec(500);
	lSpeed = 0;
	rSpeed = 0;
	wait1Msec(2000);
	int randTemp = (random[6]+2)*250;
	if(random[2])
	{
		rSpeed = BASESPEED;
		lSpeed = -1*(BASESPEED-25);
		wait1Msec(randTemp);
	}
	else
	{
		rSpeed = -1*(BASESPEED-25);
		lSpeed = BASESPEED;
		wait1Msec(randTemp);
	}
}

//When a left bumb is detected wait 100ms.
//If in this 100ms we detect the right bumper as well, then we stop both motors
//and proceed with the bothD() function. Otherwise, we stop both motors, reverse
//for a little, and then turn a random amount to the right.
void leftD()
{
	wait1Msec(100); //wait .1 sec
	if(data[1] == 'y') //check to see if perpendicular
	{
		lSpeed = 0;
		rSpeed = 0;
		bothD(); //if perpendicular
	}
	else //if not perpendicular, follow normal procedure
	{
		lSpeed = 0;
		rSpeed = 0;
		wait1Msec(50);
		rSpeed = -1*BASESPEED; //back up half a second
		lSpeed = -1*BASESPEED;
		wait1Msec(500);
		rSpeed = BASESPEED; //turn left
		lSpeed = -1*BASESPEED;
		wait1Msec((random[4]+3)*100); //500
	}
}

//When a right bumb is detected wait 100ms.
//If in this 100ms we detect the left bumper as well, then we stop both motors
//and proceed with the bothD() function. Otherwise, we stop both motors, reverse
//for a little, and then turn a random amount to the left.
void rightD()
{
	wait1Msec(100); //wait .1 sec
	if(data[0]=='y') //check to see if perpendicular
	{
		lSpeed = 0;
		rSpeed = 0;
		bothD(); //if perpendicular
	}
	else //if not perpendicular, follow normal procedure
	{
		lSpeed = 0;
		rSpeed = 0;
		wait1Msec(50);
		lSpeed = -1*BASESPEED;
		rSpeed = -1*BASESPEED;
		wait1Msec(500);
		rSpeed = -1*BASESPEED;
		lSpeed = BASESPEED;
		wait1Msec((random[4]+3)*100); //500
	}
}

void obstacle()
{
	if(data[0]=='y')
		leftD();
	else
		rightD();
}

task commTask()
{
	nxtEnableHSPort();
	nxtSetHSBaudRate(9600);  // can go as high as 921600 BAUD
	nxtHS_Mode = hsRawMode;
	while(true)
	{
		while (nxtGetAvailHSBytes() < 4) EndTimeSlice(); // wait for the two bytes to come in.
		{
			eraseDisplay();
			nxtReadRawHS(&data[0], 3*sizeof(ubyte));
			displayCenteredBigTextLine(3, "%c%c%c", data[0], data[1], data[2]);
		}
	}
}
/**
*Task that runs continuously and calls drunkTurn function every few seconds.
**/
task invertMotorsTask()
{
	while(true)
	{
		while(!objectFound)
		{
			wait1Msec((random[6]+3)*250); //wait 1 to 3 seconds (250mS resolution)
			drunkTurn();
		}
	}
}

task runMotors()
{
	while(true){
		motor[leftMotor] = lSpeed;
		motor[rightMotor] = rSpeed;
	}
}

task getReadingTask()
{
	int total_dist = 0;
	int cSuccess = 0;
	int i,j;
	while(true)
	{
		cSuccess = 0;
		for(j = 0; j < 10; j++) //we need to ignore false positives
		{
			wait1Msec(10);
			total_dist = 0;
			for(i = 0;i<SAMPLES;i++) //we need to make sure the reading is good
			{
				total_dist += SensorValue[ultraSonic];
			}
			distance = total_dist/SAMPLES;
			if(distance<=MAX_DIST)
			{
				cSuccess++;
			}
		}
		if(cSuccess>=9) //indicates if we have a 90% success rate with distance
			objectFound = true;
	}
}

task energyRate()
{
	while(true)
	{
		if(dead)
			break;
		else
		{
			while(FEEDING && energyLevel<=FULL)
			{
				energyLevel++;
				wait1Msec(1000);
			}
			while(!FEEDING && !dead)
			{
				energyLevel--;
				wait1Msec(2000);
			}
		}
	}
}

task fearState()
{
	scared = false;
	bool thirtyFlag = false;
	while(!dead)
	{
		if(!scared && fearLevel<100)
		{
			fearLevel++;
			wait1Msec(2400);
		}
		else if(State==ESCAPE && !scared)
		{
			scared = true;
			clearTimer(T1);
		}
		else if(State==ESCAPE && scared)
		{
			thirtyFlag=false;
			clearTimer(T1);
			if(fearLevel<=25)
				fearLevel=0;
			else fearLevel-=25;
		}
		else if(scared)
		{
			if(time1[T1]>=30000 && !thirtyFlag)
			{
				clearTimer(T1);
				thirtyFlag = true;
			}
			else if(thirtyFlag && time1[T1]>=30000)
			{
				thirtyFlag = false;
				scared = false;
			}
		}
	}
}

task energyState()
{
	while(1)
	{
		if(energyLevel>HUNGRY)
		{
			content = true;
			hungry = false;
			starving = false;
			dead = false;
		}
		else if(energyLevel>DANGER && energyLevel<=HUNGRY)
		{
			content = false;
			hungry = true;
			starving = false;
			dead = false;
		}
		else if(energyLevel<=DANGER && energyLevel>DEATH)
		{
			content = false;
			hungry = false;
			starving = true;
			dead = false;
		}
		else
		{
			content = false;
			hungry = false;
			starving = false;
			dead = true;
		}
	}
}
task main()
{
	startTask(runMotors);
	startTask(fearState);
	startTask(energyState);
	startTask(getReadingTask);
	startTask(invertMotorsTask);
	startTask(energyRate);
	startTask(commTask);

	energyLevel = FULL;

	avoidLSpeed = 0;
	avoidRSpeed = 0;
	escapeLSpeed = 0;
	escapeRSpeed = 0;
	investLSpeed = 0;
	investRSpeed = 0;
	feedLSpeed = 0;
	feedRSpeed = 0;
	wanderLSpeed = 0;
	wanderRSpeed = 0;
	distance = SensorValue[ultraSonic];
	while(true)
	{
		if(dead) {
			State = DEATH;
			} else if (data[0] == 'y' || data[1] == 'y') { //bumper
			State = AVOID;
			} else if (data[2] == 'y' && fearLevel > 0 && !starving) {
			State = ESCAPE;
			} else if (objectFound && energyLevel > DANGER) {
			State = INVESTIGATE;
			} else if (feeding) {
			State = FEEDING;
			} else {
			State = WANDER;
		}
		switch(State) {
		case DEATH:
			lSpeed = STOP;
			rSpeed = STOP;
			break;
		case AVOID:
			obstacle();
			break;
		case ESCAPE:
			lSpeed = escapeLSpeed;
			rSpeed = escapeRSpeed;
			break;
		case INVESTIGATE:
			targetAquired();
			break;
		case FEEDING:
			//eatingfunction
			lSpeed = feedLSpeed;
			rSpeed = feedRSpeed;
			break;
		case WANDER:
			lSpeed = wanderLSpeed;
			rSpeed = wanderRSpeed;
			break;
		}
	}
}
